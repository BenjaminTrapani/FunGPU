(let ((my-cons (lambda (x rest)
                 (lambda (sel-first?)
                   (if (> sel-first? 0) x rest))))
      (my-first (lambda (list)
                  (list 1)))
      (my-rest (lambda (list)
                 (list 0)))
      (my-list-terminator (lambda () 0)))
  (let ((my-is-empty (lambda (list) (eq? list my-list-terminator))))
    (letrec ((my-length (lambda (list)
                          (if (my-is-empty list)
                              0
                              (+ 1 (my-length (my-rest list)))))))
      (letrec ((merge-lists (lambda (first-list second-list)
                              (if (my-is-empty first-list)
                                  second-list
                                  (if (my-is-empty second-list)
                                      first-list
                                      (if (> (my-first first-list) (my-first second-list))
                                          (my-cons (my-first second-list) (merge-lists first-list (my-rest second-list)))
                                          (my-cons (my-first first-list) (merge-lists (my-rest first-list) second-list)))))))
               (split-list (lambda (the-list cur-idx begin-idx end-idx)
                             (if (> cur-idx (- begin-idx 1))
                                 (if (> end-idx cur-idx)
                                     (my-cons (my-first the-list) (split-list (my-rest the-list) (+ cur-idx 1) begin-idx end-idx))
                                     my-list-terminator)
                                 (split-list (my-rest the-list) (+ cur-idx 1) begin-idx end-idx)))))
        (letrec ((merge-sort (lambda (l)
                               (if (my-is-empty l)
                                   l
                                   (if (my-is-empty (my-rest l))
                                       l
                                       (let ((length-l (my-length l)))
                                         (let ((list-midpoint (floor (/ length-l 2))))
                                           (let ((first-l (split-list l 0 0 list-midpoint))
                                                 (second-l (split-list l 0 list-midpoint length-l)))
                                             (merge-lists (merge-sort first-l) (merge-sort second-l)))))))))
                 (my-pow (lambda (base exp)
                           (if (= exp 0)
                               1
                               (* base (my-pow base (- exp 1)))))))
          (letrec ((list-to-number (lambda (l)
                                     (if (my-is-empty l)
                                         0
                                         (let ((rem-list-len (my-length (my-rest l))))
                                           (+ (* (my-first l) (my-pow 10 rem-list-len)) (list-to-number (my-rest l))))))))
            (list-to-number (merge-sort (my-cons 5 (my-cons 1 (my-cons 4 (my-cons 3 (my-cons 2 my-list-terminator)))))))))))))
